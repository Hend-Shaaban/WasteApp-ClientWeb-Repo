/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { FocusableOption } from '@angular/cdk/a11y';
import { Directionality } from '@angular/cdk/bidi';
import { BooleanInput, NumberInput } from '@angular/cdk/coercion';
import { AfterViewInit, ChangeDetectorRef, ElementRef, EventEmitter, InjectionToken, OnChanges, OnDestroy, QueryList, TemplateRef } from '@angular/core';
import { Observable, Subject } from 'rxjs';
import { CdkStepLabel } from './step-label';
/**
 * Position state of the content of each step in stepper that is used for transitioning
 * the content into correct position upon step selection change.
 */
import * as ɵngcc0 from '@angular/core';
export declare type StepContentPositionState = 'previous' | 'current' | 'next';
/** Possible orientation of a stepper. */
export declare type StepperOrientation = 'horizontal' | 'vertical';
/** Change event emitted on selection changes. */
export declare class StepperSelectionEvent {
    /** Index of the step now selected. */
    selectedIndex: number;
    /** Index of the step previously selected. */
    previouslySelectedIndex: number;
    /** The step instance now selected. */
    selectedStep: CdkStep;
    /** The step instance previously selected. */
    previouslySelectedStep: CdkStep;
}
/** The state of each step. */
export declare type StepState = 'number' | 'edit' | 'done' | 'error' | string;
/** Enum to represent the different states of the steps. */
export declare const STEP_STATE: {
    NUMBER: string;
    EDIT: string;
    DONE: string;
    ERROR: string;
};
/** InjectionToken that can be used to specify the global stepper options. */
export declare const STEPPER_GLOBAL_OPTIONS: InjectionToken<StepperOptions>;
/**
 * InjectionToken that can be used to specify the global stepper options.
 * @deprecated Use `STEPPER_GLOBAL_OPTIONS` instead.
 * @breaking-change 8.0.0.
 */
export declare const MAT_STEPPER_GLOBAL_OPTIONS: InjectionToken<StepperOptions>;
/** Configurable options for stepper. */
export interface StepperOptions {
    /**
     * Whether the stepper should display an error state or not.
     * Default behavior is assumed to be false.
     */
    showError?: boolean;
    /**
     * Whether the stepper should display the default indicator type
     * or not.
     * Default behavior is assumed to be true.
     */
    displayDefaultIndicatorType?: boolean;
}
export declare class CdkStep implements OnChanges {
    private _stepper;
    private _stepperOptions;
    _showError: boolean;
    _displayDefaultIndicatorType: boolean;
    /** Template for step label if it exists. */
    stepLabel: CdkStepLabel;
    /** Template for step content. */
    content: TemplateRef<any>;
    /** The top level abstract control of the step. */
    stepControl: AbstractControlLike;
    /** Whether user has seen the expanded step content or not. */
    interacted: boolean;
    /** Plain text label of the step. */
    label: string;
    /** Error message to display when there's an error. */
    errorMessage: string;
    /** Aria label for the tab. */
    ariaLabel: string;
    /**
     * Reference to the element that the tab is labelled by.
     * Will be cleared if `aria-label` is set at the same time.
     */
    ariaLabelledby: string;
    /** State of the step. */
    state: StepState;
    /** Whether the user can return to this step once it has been marked as completed. */
    get editable(): boolean;
    set editable(value: boolean);
    private _editable;
    /** Whether the completion of step is optional. */
    get optional(): boolean;
    set optional(value: boolean);
    private _optional;
    /** Whether step is marked as completed. */
    get completed(): boolean;
    set completed(value: boolean);
    _completedOverride: boolean | null;
    private _getDefaultCompleted;
    /** Whether step has an error. */
    get hasError(): boolean;
    set hasError(value: boolean);
    private _customError;
    private _getDefaultError;
    /** @breaking-change 8.0.0 remove the `?` after `stepperOptions` */
    constructor(_stepper: CdkStepper, stepperOptions?: StepperOptions);
    /** Selects this step component. */
    select(): void;
    /** Resets the step to its initial state. Note that this includes resetting form data. */
    reset(): void;
    ngOnChanges(): void;
    static ngAcceptInputType_editable: BooleanInput;
    static ngAcceptInputType_hasError: BooleanInput;
    static ngAcceptInputType_optional: BooleanInput;
    static ngAcceptInputType_completed: BooleanInput;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<CdkStep>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<CdkStep, "cdk-step", ["cdkStep"], {
    "editable": "editable";
    "optional": "optional";
    "completed": "completed";
    "hasError": "hasError";
    "stepControl": "stepControl";
    "label": "label";
    "errorMessage": "errorMessage";
    "ariaLabel": "aria-label";
    "ariaLabelledby": "aria-labelledby";
    "state": "state";
}, {}, ["stepLabel"]>;
}
export declare class CdkStepper implements AfterViewInit, OnDestroy {
    private _dir;
    private _changeDetectorRef;
    private _elementRef?;
    /** Emits when the component is destroyed. */
    protected _destroyed: Subject<void>;
    /** Used for managing keyboard focus. */
    private _keyManager;
    /**
     * @breaking-change 8.0.0 Remove `| undefined` once the `_document`
     * constructor param is required.
     */
    private _document;
    /**
     * The list of step components that the stepper is holding.
     * @deprecated use `steps` instead
     * @breaking-change 9.0.0 remove this property
     */
    _steps: QueryList<CdkStep>;
    /** The list of step components that the stepper is holding. */
    get steps(): QueryList<CdkStep>;
    /**
     * The list of step headers of the steps in the stepper.
     * @deprecated Type to be changed to `QueryList<CdkStepHeader>`.
     * @breaking-change 8.0.0
     */
    _stepHeader: QueryList<FocusableOption>;
    /** Whether the validity of previous steps should be checked or not. */
    get linear(): boolean;
    set linear(value: boolean);
    private _linear;
    /** The index of the selected step. */
    get selectedIndex(): number;
    set selectedIndex(index: number);
    private _selectedIndex;
    /** The step that is selected. */
    get selected(): CdkStep;
    set selected(step: CdkStep);
    /** Event emitted when the selected step has changed. */
    selectionChange: EventEmitter<StepperSelectionEvent>;
    /** Used to track unique ID for each stepper component. */
    _groupId: number;
    protected _orientation: StepperOrientation;
    constructor(_dir: Directionality, _changeDetectorRef: ChangeDetectorRef, _elementRef?: ElementRef<HTMLElement> | undefined, _document?: any);
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    /** Selects and focuses the next step in list. */
    next(): void;
    /** Selects and focuses the previous step in list. */
    previous(): void;
    /** Resets the stepper to its initial state. Note that this includes clearing form data. */
    reset(): void;
    /** Returns a unique id for each step label element. */
    _getStepLabelId(i: number): string;
    /** Returns unique id for each step content element. */
    _getStepContentId(i: number): string;
    /** Marks the component to be change detected. */
    _stateChanged(): void;
    /** Returns position state of the step with the given index. */
    _getAnimationDirection(index: number): StepContentPositionState;
    /** Returns the type of icon to be displayed. */
    _getIndicatorType(index: number, state?: StepState): StepState;
    private _getDefaultIndicatorLogic;
    private _getGuidelineLogic;
    private _isCurrentStep;
    /** Returns the index of the currently-focused step header. */
    _getFocusIndex(): number | null;
    private _updateSelectedItemIndex;
    _onKeydown(event: KeyboardEvent): void;
    private _anyControlsInvalidOrPending;
    private _layoutDirection;
    /** Checks whether the stepper contains the focused element. */
    private _containsFocus;
    static ngAcceptInputType_editable: BooleanInput;
    static ngAcceptInputType_optional: BooleanInput;
    static ngAcceptInputType_completed: BooleanInput;
    static ngAcceptInputType_hasError: BooleanInput;
    static ngAcceptInputType_linear: BooleanInput;
    static ngAcceptInputType_selectedIndex: NumberInput;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<CdkStepper>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<CdkStepper, "[cdkStepper]", ["cdkStepper"], {
    "linear": "linear";
    "selectedIndex": "selectedIndex";
    "selected": "selected";
}, {
    "selectionChange": "selectionChange";
}, ["_steps", "_stepHeader"]>;
}
/**
 * Simplified representation of an "AbstractControl" from @angular/forms.
 * Used to avoid having to bring in @angular/forms for a single optional interface.
 * @docs-private
 */
interface AbstractControlLike {
    asyncValidator: ((control: any) => any) | null;
    dirty: boolean;
    disabled: boolean;
    enabled: boolean;
    errors: {
        [key: string]: any;
    } | null;
    invalid: boolean;
    parent: any;
    pending: boolean;
    pristine: boolean;
    root: AbstractControlLike;
    status: string;
    statusChanges: Observable<any>;
    touched: boolean;
    untouched: boolean;
    updateOn: any;
    valid: boolean;
    validator: ((control: any) => any) | null;
    value: any;
    valueChanges: Observable<any>;
    clearAsyncValidators(): void;
    clearValidators(): void;
    disable(opts?: any): void;
    enable(opts?: any): void;
    get(path: (string | number)[] | string): AbstractControlLike | null;
    getError(errorCode: string, path?: (string | number)[] | string): any;
    hasError(errorCode: string, path?: (string | number)[] | string): boolean;
    markAllAsTouched(): void;
    markAsDirty(opts?: any): void;
    markAsPending(opts?: any): void;
    markAsPristine(opts?: any): void;
    markAsTouched(opts?: any): void;
    markAsUntouched(opts?: any): void;
    patchValue(value: any, options?: Object): void;
    reset(value?: any, options?: Object): void;
    setAsyncValidators(newValidator: (control: any) => any | ((control: any) => any)[] | null): void;
    setErrors(errors: {
        [key: string]: any;
    } | null, opts?: any): void;
    setParent(parent: any): void;
    setValidators(newValidator: (control: any) => any | ((control: any) => any)[] | null): void;
    setValue(value: any, options?: Object): void;
    updateValueAndValidity(opts?: any): void;
    patchValue(value: any, options?: any): void;
    reset(formState?: any, options?: any): void;
    setValue(value: any, options?: any): void;
}
export {};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RlcHBlci5kLnRzIiwic291cmNlcyI6WyJzdGVwcGVyLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvR0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnRkEiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICpcclxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcclxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHsgRm9jdXNhYmxlT3B0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2ExMXknO1xyXG5pbXBvcnQgeyBEaXJlY3Rpb25hbGl0eSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9iaWRpJztcclxuaW1wb3J0IHsgQm9vbGVhbklucHV0LCBOdW1iZXJJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XHJcbmltcG9ydCB7IEFmdGVyVmlld0luaXQsIENoYW5nZURldGVjdG9yUmVmLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIEluamVjdGlvblRva2VuLCBPbkNoYW5nZXMsIE9uRGVzdHJveSwgUXVlcnlMaXN0LCBUZW1wbGF0ZVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IENka1N0ZXBMYWJlbCB9IGZyb20gJy4vc3RlcC1sYWJlbCc7XHJcbi8qKlxyXG4gKiBQb3NpdGlvbiBzdGF0ZSBvZiB0aGUgY29udGVudCBvZiBlYWNoIHN0ZXAgaW4gc3RlcHBlciB0aGF0IGlzIHVzZWQgZm9yIHRyYW5zaXRpb25pbmdcclxuICogdGhlIGNvbnRlbnQgaW50byBjb3JyZWN0IHBvc2l0aW9uIHVwb24gc3RlcCBzZWxlY3Rpb24gY2hhbmdlLlxyXG4gKi9cclxuZXhwb3J0IGRlY2xhcmUgdHlwZSBTdGVwQ29udGVudFBvc2l0aW9uU3RhdGUgPSAncHJldmlvdXMnIHwgJ2N1cnJlbnQnIHwgJ25leHQnO1xyXG4vKiogUG9zc2libGUgb3JpZW50YXRpb24gb2YgYSBzdGVwcGVyLiAqL1xyXG5leHBvcnQgZGVjbGFyZSB0eXBlIFN0ZXBwZXJPcmllbnRhdGlvbiA9ICdob3Jpem9udGFsJyB8ICd2ZXJ0aWNhbCc7XHJcbi8qKiBDaGFuZ2UgZXZlbnQgZW1pdHRlZCBvbiBzZWxlY3Rpb24gY2hhbmdlcy4gKi9cclxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgU3RlcHBlclNlbGVjdGlvbkV2ZW50IHtcclxuICAgIC8qKiBJbmRleCBvZiB0aGUgc3RlcCBub3cgc2VsZWN0ZWQuICovXHJcbiAgICBzZWxlY3RlZEluZGV4OiBudW1iZXI7XHJcbiAgICAvKiogSW5kZXggb2YgdGhlIHN0ZXAgcHJldmlvdXNseSBzZWxlY3RlZC4gKi9cclxuICAgIHByZXZpb3VzbHlTZWxlY3RlZEluZGV4OiBudW1iZXI7XHJcbiAgICAvKiogVGhlIHN0ZXAgaW5zdGFuY2Ugbm93IHNlbGVjdGVkLiAqL1xyXG4gICAgc2VsZWN0ZWRTdGVwOiBDZGtTdGVwO1xyXG4gICAgLyoqIFRoZSBzdGVwIGluc3RhbmNlIHByZXZpb3VzbHkgc2VsZWN0ZWQuICovXHJcbiAgICBwcmV2aW91c2x5U2VsZWN0ZWRTdGVwOiBDZGtTdGVwO1xyXG59XHJcbi8qKiBUaGUgc3RhdGUgb2YgZWFjaCBzdGVwLiAqL1xyXG5leHBvcnQgZGVjbGFyZSB0eXBlIFN0ZXBTdGF0ZSA9ICdudW1iZXInIHwgJ2VkaXQnIHwgJ2RvbmUnIHwgJ2Vycm9yJyB8IHN0cmluZztcclxuLyoqIEVudW0gdG8gcmVwcmVzZW50IHRoZSBkaWZmZXJlbnQgc3RhdGVzIG9mIHRoZSBzdGVwcy4gKi9cclxuZXhwb3J0IGRlY2xhcmUgY29uc3QgU1RFUF9TVEFURToge1xyXG4gICAgTlVNQkVSOiBzdHJpbmc7XHJcbiAgICBFRElUOiBzdHJpbmc7XHJcbiAgICBET05FOiBzdHJpbmc7XHJcbiAgICBFUlJPUjogc3RyaW5nO1xyXG59O1xyXG4vKiogSW5qZWN0aW9uVG9rZW4gdGhhdCBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IHRoZSBnbG9iYWwgc3RlcHBlciBvcHRpb25zLiAqL1xyXG5leHBvcnQgZGVjbGFyZSBjb25zdCBTVEVQUEVSX0dMT0JBTF9PUFRJT05TOiBJbmplY3Rpb25Ub2tlbjxTdGVwcGVyT3B0aW9ucz47XHJcbi8qKlxyXG4gKiBJbmplY3Rpb25Ub2tlbiB0aGF0IGNhbiBiZSB1c2VkIHRvIHNwZWNpZnkgdGhlIGdsb2JhbCBzdGVwcGVyIG9wdGlvbnMuXHJcbiAqIEBkZXByZWNhdGVkIFVzZSBgU1RFUFBFUl9HTE9CQUxfT1BUSU9OU2AgaW5zdGVhZC5cclxuICogQGJyZWFraW5nLWNoYW5nZSA4LjAuMC5cclxuICovXHJcbmV4cG9ydCBkZWNsYXJlIGNvbnN0IE1BVF9TVEVQUEVSX0dMT0JBTF9PUFRJT05TOiBJbmplY3Rpb25Ub2tlbjxTdGVwcGVyT3B0aW9ucz47XHJcbi8qKiBDb25maWd1cmFibGUgb3B0aW9ucyBmb3Igc3RlcHBlci4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBTdGVwcGVyT3B0aW9ucyB7XHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdGhlIHN0ZXBwZXIgc2hvdWxkIGRpc3BsYXkgYW4gZXJyb3Igc3RhdGUgb3Igbm90LlxyXG4gICAgICogRGVmYXVsdCBiZWhhdmlvciBpcyBhc3N1bWVkIHRvIGJlIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBzaG93RXJyb3I/OiBib29sZWFuO1xyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoZSBzdGVwcGVyIHNob3VsZCBkaXNwbGF5IHRoZSBkZWZhdWx0IGluZGljYXRvciB0eXBlXHJcbiAgICAgKiBvciBub3QuXHJcbiAgICAgKiBEZWZhdWx0IGJlaGF2aW9yIGlzIGFzc3VtZWQgdG8gYmUgdHJ1ZS5cclxuICAgICAqL1xyXG4gICAgZGlzcGxheURlZmF1bHRJbmRpY2F0b3JUeXBlPzogYm9vbGVhbjtcclxufVxyXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBDZGtTdGVwIGltcGxlbWVudHMgT25DaGFuZ2VzIHtcclxuICAgIHByaXZhdGUgX3N0ZXBwZXI7XHJcbiAgICBwcml2YXRlIF9zdGVwcGVyT3B0aW9ucztcclxuICAgIF9zaG93RXJyb3I6IGJvb2xlYW47XHJcbiAgICBfZGlzcGxheURlZmF1bHRJbmRpY2F0b3JUeXBlOiBib29sZWFuO1xyXG4gICAgLyoqIFRlbXBsYXRlIGZvciBzdGVwIGxhYmVsIGlmIGl0IGV4aXN0cy4gKi9cclxuICAgIHN0ZXBMYWJlbDogQ2RrU3RlcExhYmVsO1xyXG4gICAgLyoqIFRlbXBsYXRlIGZvciBzdGVwIGNvbnRlbnQuICovXHJcbiAgICBjb250ZW50OiBUZW1wbGF0ZVJlZjxhbnk+O1xyXG4gICAgLyoqIFRoZSB0b3AgbGV2ZWwgYWJzdHJhY3QgY29udHJvbCBvZiB0aGUgc3RlcC4gKi9cclxuICAgIHN0ZXBDb250cm9sOiBBYnN0cmFjdENvbnRyb2xMaWtlO1xyXG4gICAgLyoqIFdoZXRoZXIgdXNlciBoYXMgc2VlbiB0aGUgZXhwYW5kZWQgc3RlcCBjb250ZW50IG9yIG5vdC4gKi9cclxuICAgIGludGVyYWN0ZWQ6IGJvb2xlYW47XHJcbiAgICAvKiogUGxhaW4gdGV4dCBsYWJlbCBvZiB0aGUgc3RlcC4gKi9cclxuICAgIGxhYmVsOiBzdHJpbmc7XHJcbiAgICAvKiogRXJyb3IgbWVzc2FnZSB0byBkaXNwbGF5IHdoZW4gdGhlcmUncyBhbiBlcnJvci4gKi9cclxuICAgIGVycm9yTWVzc2FnZTogc3RyaW5nO1xyXG4gICAgLyoqIEFyaWEgbGFiZWwgZm9yIHRoZSB0YWIuICovXHJcbiAgICBhcmlhTGFiZWw6IHN0cmluZztcclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoZSBlbGVtZW50IHRoYXQgdGhlIHRhYiBpcyBsYWJlbGxlZCBieS5cclxuICAgICAqIFdpbGwgYmUgY2xlYXJlZCBpZiBgYXJpYS1sYWJlbGAgaXMgc2V0IGF0IHRoZSBzYW1lIHRpbWUuXHJcbiAgICAgKi9cclxuICAgIGFyaWFMYWJlbGxlZGJ5OiBzdHJpbmc7XHJcbiAgICAvKiogU3RhdGUgb2YgdGhlIHN0ZXAuICovXHJcbiAgICBzdGF0ZTogU3RlcFN0YXRlO1xyXG4gICAgLyoqIFdoZXRoZXIgdGhlIHVzZXIgY2FuIHJldHVybiB0byB0aGlzIHN0ZXAgb25jZSBpdCBoYXMgYmVlbiBtYXJrZWQgYXMgY29tcGxldGVkLiAqL1xyXG4gICAgZ2V0IGVkaXRhYmxlKCk6IGJvb2xlYW47XHJcbiAgICBzZXQgZWRpdGFibGUodmFsdWU6IGJvb2xlYW4pO1xyXG4gICAgcHJpdmF0ZSBfZWRpdGFibGU7XHJcbiAgICAvKiogV2hldGhlciB0aGUgY29tcGxldGlvbiBvZiBzdGVwIGlzIG9wdGlvbmFsLiAqL1xyXG4gICAgZ2V0IG9wdGlvbmFsKCk6IGJvb2xlYW47XHJcbiAgICBzZXQgb3B0aW9uYWwodmFsdWU6IGJvb2xlYW4pO1xyXG4gICAgcHJpdmF0ZSBfb3B0aW9uYWw7XHJcbiAgICAvKiogV2hldGhlciBzdGVwIGlzIG1hcmtlZCBhcyBjb21wbGV0ZWQuICovXHJcbiAgICBnZXQgY29tcGxldGVkKCk6IGJvb2xlYW47XHJcbiAgICBzZXQgY29tcGxldGVkKHZhbHVlOiBib29sZWFuKTtcclxuICAgIF9jb21wbGV0ZWRPdmVycmlkZTogYm9vbGVhbiB8IG51bGw7XHJcbiAgICBwcml2YXRlIF9nZXREZWZhdWx0Q29tcGxldGVkO1xyXG4gICAgLyoqIFdoZXRoZXIgc3RlcCBoYXMgYW4gZXJyb3IuICovXHJcbiAgICBnZXQgaGFzRXJyb3IoKTogYm9vbGVhbjtcclxuICAgIHNldCBoYXNFcnJvcih2YWx1ZTogYm9vbGVhbik7XHJcbiAgICBwcml2YXRlIF9jdXN0b21FcnJvcjtcclxuICAgIHByaXZhdGUgX2dldERlZmF1bHRFcnJvcjtcclxuICAgIC8qKiBAYnJlYWtpbmctY2hhbmdlIDguMC4wIHJlbW92ZSB0aGUgYD9gIGFmdGVyIGBzdGVwcGVyT3B0aW9uc2AgKi9cclxuICAgIGNvbnN0cnVjdG9yKF9zdGVwcGVyOiBDZGtTdGVwcGVyLCBzdGVwcGVyT3B0aW9ucz86IFN0ZXBwZXJPcHRpb25zKTtcclxuICAgIC8qKiBTZWxlY3RzIHRoaXMgc3RlcCBjb21wb25lbnQuICovXHJcbiAgICBzZWxlY3QoKTogdm9pZDtcclxuICAgIC8qKiBSZXNldHMgdGhlIHN0ZXAgdG8gaXRzIGluaXRpYWwgc3RhdGUuIE5vdGUgdGhhdCB0aGlzIGluY2x1ZGVzIHJlc2V0dGluZyBmb3JtIGRhdGEuICovXHJcbiAgICByZXNldCgpOiB2b2lkO1xyXG4gICAgbmdPbkNoYW5nZXMoKTogdm9pZDtcclxuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9lZGl0YWJsZTogQm9vbGVhbklucHV0O1xyXG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX2hhc0Vycm9yOiBCb29sZWFuSW5wdXQ7XHJcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfb3B0aW9uYWw6IEJvb2xlYW5JbnB1dDtcclxuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9jb21wbGV0ZWQ6IEJvb2xlYW5JbnB1dDtcclxufVxyXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBDZGtTdGVwcGVyIGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcclxuICAgIHByaXZhdGUgX2RpcjtcclxuICAgIHByaXZhdGUgX2NoYW5nZURldGVjdG9yUmVmO1xyXG4gICAgcHJpdmF0ZSBfZWxlbWVudFJlZj87XHJcbiAgICAvKiogRW1pdHMgd2hlbiB0aGUgY29tcG9uZW50IGlzIGRlc3Ryb3llZC4gKi9cclxuICAgIHByb3RlY3RlZCBfZGVzdHJveWVkOiBTdWJqZWN0PHZvaWQ+O1xyXG4gICAgLyoqIFVzZWQgZm9yIG1hbmFnaW5nIGtleWJvYXJkIGZvY3VzLiAqL1xyXG4gICAgcHJpdmF0ZSBfa2V5TWFuYWdlcjtcclxuICAgIC8qKlxyXG4gICAgICogQGJyZWFraW5nLWNoYW5nZSA4LjAuMCBSZW1vdmUgYHwgdW5kZWZpbmVkYCBvbmNlIHRoZSBgX2RvY3VtZW50YFxyXG4gICAgICogY29uc3RydWN0b3IgcGFyYW0gaXMgcmVxdWlyZWQuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgX2RvY3VtZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbGlzdCBvZiBzdGVwIGNvbXBvbmVudHMgdGhhdCB0aGUgc3RlcHBlciBpcyBob2xkaW5nLlxyXG4gICAgICogQGRlcHJlY2F0ZWQgdXNlIGBzdGVwc2AgaW5zdGVhZFxyXG4gICAgICogQGJyZWFraW5nLWNoYW5nZSA5LjAuMCByZW1vdmUgdGhpcyBwcm9wZXJ0eVxyXG4gICAgICovXHJcbiAgICBfc3RlcHM6IFF1ZXJ5TGlzdDxDZGtTdGVwPjtcclxuICAgIC8qKiBUaGUgbGlzdCBvZiBzdGVwIGNvbXBvbmVudHMgdGhhdCB0aGUgc3RlcHBlciBpcyBob2xkaW5nLiAqL1xyXG4gICAgZ2V0IHN0ZXBzKCk6IFF1ZXJ5TGlzdDxDZGtTdGVwPjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGxpc3Qgb2Ygc3RlcCBoZWFkZXJzIG9mIHRoZSBzdGVwcyBpbiB0aGUgc3RlcHBlci5cclxuICAgICAqIEBkZXByZWNhdGVkIFR5cGUgdG8gYmUgY2hhbmdlZCB0byBgUXVlcnlMaXN0PENka1N0ZXBIZWFkZXI+YC5cclxuICAgICAqIEBicmVha2luZy1jaGFuZ2UgOC4wLjBcclxuICAgICAqL1xyXG4gICAgX3N0ZXBIZWFkZXI6IFF1ZXJ5TGlzdDxGb2N1c2FibGVPcHRpb24+O1xyXG4gICAgLyoqIFdoZXRoZXIgdGhlIHZhbGlkaXR5IG9mIHByZXZpb3VzIHN0ZXBzIHNob3VsZCBiZSBjaGVja2VkIG9yIG5vdC4gKi9cclxuICAgIGdldCBsaW5lYXIoKTogYm9vbGVhbjtcclxuICAgIHNldCBsaW5lYXIodmFsdWU6IGJvb2xlYW4pO1xyXG4gICAgcHJpdmF0ZSBfbGluZWFyO1xyXG4gICAgLyoqIFRoZSBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgc3RlcC4gKi9cclxuICAgIGdldCBzZWxlY3RlZEluZGV4KCk6IG51bWJlcjtcclxuICAgIHNldCBzZWxlY3RlZEluZGV4KGluZGV4OiBudW1iZXIpO1xyXG4gICAgcHJpdmF0ZSBfc2VsZWN0ZWRJbmRleDtcclxuICAgIC8qKiBUaGUgc3RlcCB0aGF0IGlzIHNlbGVjdGVkLiAqL1xyXG4gICAgZ2V0IHNlbGVjdGVkKCk6IENka1N0ZXA7XHJcbiAgICBzZXQgc2VsZWN0ZWQoc3RlcDogQ2RrU3RlcCk7XHJcbiAgICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBzZWxlY3RlZCBzdGVwIGhhcyBjaGFuZ2VkLiAqL1xyXG4gICAgc2VsZWN0aW9uQ2hhbmdlOiBFdmVudEVtaXR0ZXI8U3RlcHBlclNlbGVjdGlvbkV2ZW50PjtcclxuICAgIC8qKiBVc2VkIHRvIHRyYWNrIHVuaXF1ZSBJRCBmb3IgZWFjaCBzdGVwcGVyIGNvbXBvbmVudC4gKi9cclxuICAgIF9ncm91cElkOiBudW1iZXI7XHJcbiAgICBwcm90ZWN0ZWQgX29yaWVudGF0aW9uOiBTdGVwcGVyT3JpZW50YXRpb247XHJcbiAgICBjb25zdHJ1Y3RvcihfZGlyOiBEaXJlY3Rpb25hbGl0eSwgX2NoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZiwgX2VsZW1lbnRSZWY/OiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PiB8IHVuZGVmaW5lZCwgX2RvY3VtZW50PzogYW55KTtcclxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkO1xyXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcclxuICAgIC8qKiBTZWxlY3RzIGFuZCBmb2N1c2VzIHRoZSBuZXh0IHN0ZXAgaW4gbGlzdC4gKi9cclxuICAgIG5leHQoKTogdm9pZDtcclxuICAgIC8qKiBTZWxlY3RzIGFuZCBmb2N1c2VzIHRoZSBwcmV2aW91cyBzdGVwIGluIGxpc3QuICovXHJcbiAgICBwcmV2aW91cygpOiB2b2lkO1xyXG4gICAgLyoqIFJlc2V0cyB0aGUgc3RlcHBlciB0byBpdHMgaW5pdGlhbCBzdGF0ZS4gTm90ZSB0aGF0IHRoaXMgaW5jbHVkZXMgY2xlYXJpbmcgZm9ybSBkYXRhLiAqL1xyXG4gICAgcmVzZXQoKTogdm9pZDtcclxuICAgIC8qKiBSZXR1cm5zIGEgdW5pcXVlIGlkIGZvciBlYWNoIHN0ZXAgbGFiZWwgZWxlbWVudC4gKi9cclxuICAgIF9nZXRTdGVwTGFiZWxJZChpOiBudW1iZXIpOiBzdHJpbmc7XHJcbiAgICAvKiogUmV0dXJucyB1bmlxdWUgaWQgZm9yIGVhY2ggc3RlcCBjb250ZW50IGVsZW1lbnQuICovXHJcbiAgICBfZ2V0U3RlcENvbnRlbnRJZChpOiBudW1iZXIpOiBzdHJpbmc7XHJcbiAgICAvKiogTWFya3MgdGhlIGNvbXBvbmVudCB0byBiZSBjaGFuZ2UgZGV0ZWN0ZWQuICovXHJcbiAgICBfc3RhdGVDaGFuZ2VkKCk6IHZvaWQ7XHJcbiAgICAvKiogUmV0dXJucyBwb3NpdGlvbiBzdGF0ZSBvZiB0aGUgc3RlcCB3aXRoIHRoZSBnaXZlbiBpbmRleC4gKi9cclxuICAgIF9nZXRBbmltYXRpb25EaXJlY3Rpb24oaW5kZXg6IG51bWJlcik6IFN0ZXBDb250ZW50UG9zaXRpb25TdGF0ZTtcclxuICAgIC8qKiBSZXR1cm5zIHRoZSB0eXBlIG9mIGljb24gdG8gYmUgZGlzcGxheWVkLiAqL1xyXG4gICAgX2dldEluZGljYXRvclR5cGUoaW5kZXg6IG51bWJlciwgc3RhdGU/OiBTdGVwU3RhdGUpOiBTdGVwU3RhdGU7XHJcbiAgICBwcml2YXRlIF9nZXREZWZhdWx0SW5kaWNhdG9yTG9naWM7XHJcbiAgICBwcml2YXRlIF9nZXRHdWlkZWxpbmVMb2dpYztcclxuICAgIHByaXZhdGUgX2lzQ3VycmVudFN0ZXA7XHJcbiAgICAvKiogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGN1cnJlbnRseS1mb2N1c2VkIHN0ZXAgaGVhZGVyLiAqL1xyXG4gICAgX2dldEZvY3VzSW5kZXgoKTogbnVtYmVyIHwgbnVsbDtcclxuICAgIHByaXZhdGUgX3VwZGF0ZVNlbGVjdGVkSXRlbUluZGV4O1xyXG4gICAgX29uS2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQ7XHJcbiAgICBwcml2YXRlIF9hbnlDb250cm9sc0ludmFsaWRPclBlbmRpbmc7XHJcbiAgICBwcml2YXRlIF9sYXlvdXREaXJlY3Rpb247XHJcbiAgICAvKiogQ2hlY2tzIHdoZXRoZXIgdGhlIHN0ZXBwZXIgY29udGFpbnMgdGhlIGZvY3VzZWQgZWxlbWVudC4gKi9cclxuICAgIHByaXZhdGUgX2NvbnRhaW5zRm9jdXM7XHJcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfZWRpdGFibGU6IEJvb2xlYW5JbnB1dDtcclxuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9vcHRpb25hbDogQm9vbGVhbklucHV0O1xyXG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX2NvbXBsZXRlZDogQm9vbGVhbklucHV0O1xyXG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX2hhc0Vycm9yOiBCb29sZWFuSW5wdXQ7XHJcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfbGluZWFyOiBCb29sZWFuSW5wdXQ7XHJcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfc2VsZWN0ZWRJbmRleDogTnVtYmVySW5wdXQ7XHJcbn1cclxuLyoqXHJcbiAqIFNpbXBsaWZpZWQgcmVwcmVzZW50YXRpb24gb2YgYW4gXCJBYnN0cmFjdENvbnRyb2xcIiBmcm9tIEBhbmd1bGFyL2Zvcm1zLlxyXG4gKiBVc2VkIHRvIGF2b2lkIGhhdmluZyB0byBicmluZyBpbiBAYW5ndWxhci9mb3JtcyBmb3IgYSBzaW5nbGUgb3B0aW9uYWwgaW50ZXJmYWNlLlxyXG4gKiBAZG9jcy1wcml2YXRlXHJcbiAqL1xyXG5pbnRlcmZhY2UgQWJzdHJhY3RDb250cm9sTGlrZSB7XHJcbiAgICBhc3luY1ZhbGlkYXRvcjogKChjb250cm9sOiBhbnkpID0+IGFueSkgfCBudWxsO1xyXG4gICAgZGlydHk6IGJvb2xlYW47XHJcbiAgICBkaXNhYmxlZDogYm9vbGVhbjtcclxuICAgIGVuYWJsZWQ6IGJvb2xlYW47XHJcbiAgICBlcnJvcnM6IHtcclxuICAgICAgICBba2V5OiBzdHJpbmddOiBhbnk7XHJcbiAgICB9IHwgbnVsbDtcclxuICAgIGludmFsaWQ6IGJvb2xlYW47XHJcbiAgICBwYXJlbnQ6IGFueTtcclxuICAgIHBlbmRpbmc6IGJvb2xlYW47XHJcbiAgICBwcmlzdGluZTogYm9vbGVhbjtcclxuICAgIHJvb3Q6IEFic3RyYWN0Q29udHJvbExpa2U7XHJcbiAgICBzdGF0dXM6IHN0cmluZztcclxuICAgIHN0YXR1c0NoYW5nZXM6IE9ic2VydmFibGU8YW55PjtcclxuICAgIHRvdWNoZWQ6IGJvb2xlYW47XHJcbiAgICB1bnRvdWNoZWQ6IGJvb2xlYW47XHJcbiAgICB1cGRhdGVPbjogYW55O1xyXG4gICAgdmFsaWQ6IGJvb2xlYW47XHJcbiAgICB2YWxpZGF0b3I6ICgoY29udHJvbDogYW55KSA9PiBhbnkpIHwgbnVsbDtcclxuICAgIHZhbHVlOiBhbnk7XHJcbiAgICB2YWx1ZUNoYW5nZXM6IE9ic2VydmFibGU8YW55PjtcclxuICAgIGNsZWFyQXN5bmNWYWxpZGF0b3JzKCk6IHZvaWQ7XHJcbiAgICBjbGVhclZhbGlkYXRvcnMoKTogdm9pZDtcclxuICAgIGRpc2FibGUob3B0cz86IGFueSk6IHZvaWQ7XHJcbiAgICBlbmFibGUob3B0cz86IGFueSk6IHZvaWQ7XHJcbiAgICBnZXQocGF0aDogKHN0cmluZyB8IG51bWJlcilbXSB8IHN0cmluZyk6IEFic3RyYWN0Q29udHJvbExpa2UgfCBudWxsO1xyXG4gICAgZ2V0RXJyb3IoZXJyb3JDb2RlOiBzdHJpbmcsIHBhdGg/OiAoc3RyaW5nIHwgbnVtYmVyKVtdIHwgc3RyaW5nKTogYW55O1xyXG4gICAgaGFzRXJyb3IoZXJyb3JDb2RlOiBzdHJpbmcsIHBhdGg/OiAoc3RyaW5nIHwgbnVtYmVyKVtdIHwgc3RyaW5nKTogYm9vbGVhbjtcclxuICAgIG1hcmtBbGxBc1RvdWNoZWQoKTogdm9pZDtcclxuICAgIG1hcmtBc0RpcnR5KG9wdHM/OiBhbnkpOiB2b2lkO1xyXG4gICAgbWFya0FzUGVuZGluZyhvcHRzPzogYW55KTogdm9pZDtcclxuICAgIG1hcmtBc1ByaXN0aW5lKG9wdHM/OiBhbnkpOiB2b2lkO1xyXG4gICAgbWFya0FzVG91Y2hlZChvcHRzPzogYW55KTogdm9pZDtcclxuICAgIG1hcmtBc1VudG91Y2hlZChvcHRzPzogYW55KTogdm9pZDtcclxuICAgIHBhdGNoVmFsdWUodmFsdWU6IGFueSwgb3B0aW9ucz86IE9iamVjdCk6IHZvaWQ7XHJcbiAgICByZXNldCh2YWx1ZT86IGFueSwgb3B0aW9ucz86IE9iamVjdCk6IHZvaWQ7XHJcbiAgICBzZXRBc3luY1ZhbGlkYXRvcnMobmV3VmFsaWRhdG9yOiAoY29udHJvbDogYW55KSA9PiBhbnkgfCAoKGNvbnRyb2w6IGFueSkgPT4gYW55KVtdIHwgbnVsbCk6IHZvaWQ7XHJcbiAgICBzZXRFcnJvcnMoZXJyb3JzOiB7XHJcbiAgICAgICAgW2tleTogc3RyaW5nXTogYW55O1xyXG4gICAgfSB8IG51bGwsIG9wdHM/OiBhbnkpOiB2b2lkO1xyXG4gICAgc2V0UGFyZW50KHBhcmVudDogYW55KTogdm9pZDtcclxuICAgIHNldFZhbGlkYXRvcnMobmV3VmFsaWRhdG9yOiAoY29udHJvbDogYW55KSA9PiBhbnkgfCAoKGNvbnRyb2w6IGFueSkgPT4gYW55KVtdIHwgbnVsbCk6IHZvaWQ7XHJcbiAgICBzZXRWYWx1ZSh2YWx1ZTogYW55LCBvcHRpb25zPzogT2JqZWN0KTogdm9pZDtcclxuICAgIHVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkob3B0cz86IGFueSk6IHZvaWQ7XHJcbiAgICBwYXRjaFZhbHVlKHZhbHVlOiBhbnksIG9wdGlvbnM/OiBhbnkpOiB2b2lkO1xyXG4gICAgcmVzZXQoZm9ybVN0YXRlPzogYW55LCBvcHRpb25zPzogYW55KTogdm9pZDtcclxuICAgIHNldFZhbHVlKHZhbHVlOiBhbnksIG9wdGlvbnM/OiBhbnkpOiB2b2lkO1xyXG59XHJcbmV4cG9ydCB7fTtcclxuIl19